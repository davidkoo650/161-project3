Egg was not necessary for this problem, so arg was used to achieve our desired goal. 

The main idea here is that there is a off-by-one error caused on line 9 of agent-brown that can be manipulated such that we can overwrite $ebp of our invoke function. Overwriting this $ebp will allow us to jump into the shell code located inside of our buffer. Additionally, because the flip function distorts our original input, we pre-flip our input such that the flip function will store our desired values into the buffer. 

We overwrite the LSB of our $ebp so that it points to an address located inside of the buffer. This will be our fake $ebp address. Directly 4 bytes above that fake address we also create a fake return address. This fake return address will point to the beginning of our buffer, where our shell code will be located. 

ebp at 0xbffff5e8, eip at 0xbffff5ec
(gdb) x/64x buf
0xbffff5a8:	0x895e1feb	0xc0310876	0x89074688	0x0bb00c46
0xbffff5b8:	0x4e8df389	0x0c568d08	0xdb3180cd	0xcd40d889
0xbffff5c8:	0xffdce880	0x622fffff	0x732f6e69	0x61616168
0xbffff5d8:	0x61616161	0x61616161	0x61616161	0xbffff5a8
0xbffff5e8:	0xbffff5e0

Above is the gdb output of ‘x/64x buf’ immediately after we execute flip(buf, in). As we can see, the ebp is at 0xbffff5ec with the value 0xbffff5e0. This is pointing to the address 8 bytes prior to our ebp, which we know is located inside of our buffer. Directly 4 bytes above that is the address 0xbffff5a8, which is the beginning of our buffer. This LSB overwrite of our ebp eventually results in a jump to the beginning of the buffer after a series of moves and pops in the function epilogue. After we make the jump, the shell code generated by our pre-flipped input will allow us to gain access to our desired privileges.
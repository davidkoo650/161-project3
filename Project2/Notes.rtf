{\rtf1\ansi\ansicpg1252\cocoartf1504\cocoasubrtf760
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww15660\viewh14260\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Office Hours Questions:\
\
1. Distinction between RSA Encrypt, RSA Decrypt, RSA Sign, RSA Verify? \
2. Approach how to choose which encryption and verification schemes to use? \
3. Advice on how to do append? Using last block of cipher text as the IV for encrypting the appending data. \
4. Make sure that I\'92m using CFBEncrypter and XORKeyStream correctly. \
5. Go over InitUser and GetUser logic. Entire logical procedure or initializing user, loading user, storing the file, loading the file, and appending the file. \
\
Question by Question\
\
InitUser: \
\
Q: Am I generating the keys correctly? \
Q: Recommendations on workflow and testing for correctness? \
\
1. Generate CFB Encryptor key. \
2. Generate HMAC to create hash of username concatenated with password to be able to use as key for datastore. \
3. Create public key with a 128 byte long salt to use for key store. \
4. Generate private RSA Key, and set the public key to the one generated by PBKDF2Key.\
5. Use RSA Encryption to encrypt userdatabytes generated by json. Marshal and then stored that data into datastoreset. \
\
GetUser: \
\
1. Get the publicKey from KeyStoreGet.\
2. Get the encrypted bytes using DataStoreGet. \
3. Use RSADecrypt to obtain the original bytes. \
\
StoreFile:\
\
1. Generate HMAC with the user\'92s HMAC key.\
2. Use HMAC to hash filename. \
3. Try to implement CFB Encryption. \
4. Use CFB Encrypted Data as data, and the key as the hashedFileName under HMAC.  \
\
Append File: \
\
Right direction for appending? \
\
1. Get HMAC, and then Hash filename to get the correct file name stored as key in datastore.\
2. Fetch the encrypted data by calling DataStoreGet.\
3. Get the lastBlock of cipher text.\
4. Encrypt using last block of cipher text as the initialization vector. \
5. Then append that encrypted data onto the encrypted data. \
6. Finished. \
\
\
Q: What is the whole point of RSA? \
Q: General advice on the most difficult components of the project? \
Q: \
\
Notes Office Hours: \
\
1. PBKDF2 can produce kiloBytes of key material as a function of the username and password. \
\
- PBKDF2 will be used to generate key material. \
- AES 128 bit. HMAC 128 or 256 bits. \
- PBKDF2 is used for password hashing. Very expensive per guest. \
\
2. \
\
3. When in doubt, add another layer of indirection? \
\
- Store a pointer to foo in the location. \
- DataStore. Deterministic gets me to an encrypted blob for the meta data structure. Stored in a random location. File blocks are stored in a random location. Unique keys and IVs. \
\
4. Easy solution for revocation if you use delete/add. Random locations. \
\
5. Change location and the private key of the file. KeyStore can be used to store keys at a random location. \
\
6. Private key encryption for each file. Appending. Add another layer of indirection. Add into the array. Efficient update can be O(n) for number of updates that have already been done. Basically chunk the file. CFB allows you to write how many bytes you want without having to pad anything. Several design decisions like PBKDF2, HMAC, CFBEncryption. Choose easier and powerful primitives. \
\
7. When in doubt, add another layer of indirection. Key management idea as well. \
\
8. Hash chains. Split file into blocks. Doesn\'92t matter what block size is used. File doesn\'92t need to be broken down into consistent files. Encrypt IV and Big Mac and put in another location. Do all computation in one block. Do append in a similar way. Metadata is a pointer to all of the blocks inside of the file. Add another layer of indirection. Every metadata needs another key. \
\

\b 9. Revocation, moved and with a different key it should be safe. If you use a private key for each file, revocation becomes easier. \

\b0 \
11. Hashing the uuid. \
\
12. Hard to test the security component of the file. The design document is created for the security properties. \
\
13. Project is due on Monday. Late slip due on Wednesday. Monday after is non-webcasted version of the lecture. \
\
14. When appending the file, point back to the previous append? Metadata. Add another layer of indirection. Pointer to all of the individual components of the file. \
\
17. Never explicitly declare HMAC. Don\'92t do too much marshaling. Don\'92t ever marshal an HMAC object. Don\'92t marshal HMAC object. \
\
18. Use metadata and another layer of indirection. Includes encrypting keys with keys. \
\
19. Store the keys somewhere. \
\
20. Don\'92t ever reuse IVs. \
\
21. uuids 2^16. Revocation change uuids for extra security. \
\
22. uuid lib. Makes life a lot more easier. \
\
23. Sharerecord. All information to get the file and encrypt the file. Tell them where random location is.  Make sure it is all secure. \
\
24. If all data structures use bytes or uuids you are fine. \
\
25. KeystoreSet is only used for RSA. \
\
26. ShareRecord is used just for user to user. Tuck it in a datastore at a random location. \
\
27. In general for CFB you need to know what the IV is, but the IV is public. \
\
28. PBKDF2 is deliberately slow (slows down brute force), and produces larger bit strings. \
\
29. Point is the design, not coding. This is the central issue here. \
\
30. Overwrite everything is nice and easy. \
\
31. New key for every file and new key for metadata. Add another layer of indirection. List of keys for all of the files. \
\
\
Security Measures:\
\
1. Brute forcing. \
\
2. Try to share a file to herself. \
\
3. Cannot read the encryption. \
\
Pull from spec to verify what is needed. \
\
\
Questions for Office Hours:\
\
Go over shareFile and receiveFile implementation. \
\
Go over revocation implementation. \
\
Go over StoreFile and append implementation. The key here is that we are storing the fileLocation, and the fileKeys within each user struct. \
Every time that the metadata and/or the user struct is updated, we reencrypt before storing into datastore again. \
\
Specifically, talk about the desirability of two map within each user struct that keeps track of fileLocation and fileKeys, respectively.\
SharingRecord holds the file location and file keys. We update the user struct maps and then re encrypt the user struct before \
Storing it into datastore again. Is this the right approach? \
\
When doing revocation:\
\
Generation of new keys and new locations. Is it fine to just call randomBytes and then convert that into a string using uuid? After updating these, I\
can update the mappings inside of the user struct. \
\
Encrypting file data and metadata with the same key? FileKey? \
}